#include <cmath>
#include <cstdio>
#include <vector>
#include <iostream>
#include <algorithm>
#include <string>
using namespace std;

#define ll long long
#define MAX_LENGTH 510
#define MAX_N 1000000007

ll dp[MAX_LENGTH][MAX_LENGTH/2][MAX_LENGTH/2] = {0};

ll NPalindromes(const string &str, int N) {
    int length = str.length(); // אורך המילה שבודקים
    int num_group = (length + 1) / 2; // כמות זוגות האותיות 
    int num_mismatch = 0; //כמות הטעויות
    //לולאה שעוברת על ל המילה ובודקת אם היא פלינדרום
    for(int i=0; i<num_group; i++) {
        if(str[i] != str[length-i-1]) {
            num_mismatch++; // אם המילה לא פלינדרום היא מעלה את הטעות ב1
        }
    }
    dp[0][0][0] = 1;
    
    // משנים n אותיות 
    for(int n=0; n<=N; n++) {
        // מסתכלים על חצי מחרוזת 
        for(int k=1; k<=num_group; k++) {
            // כמות הפעמים שיש טעות והמספר לא יכול להיות פלינדרום
            for(int b=0; b<=num_mismatch; b++) {
               // בודק אם אנחנו באמצע כשהמחרוזת אי זוגית 
               if(k-1 == length-k) {          
                    //אם במקום האי זוגי כניס את כמות החילופים שמצאנו עד כה
                    dp[n][k][b] = dp[n][k-1][b];
                    // אם יש לנו אפשרות לשנות לפחות עוד אות אחת                  
                    if(n>=1) }
                        {                       
                    //מעלה את כמות החלפות ב25 כי אפשר עוד 25 החלפות 
                            dp[n][k][b] = (dp[n][k][b] + 25 * dp[n-1][k-1][b]) % MAX_N;
                        }
                    
                }
                //אם אנחנו לא באמצע והאותיות שוות 
                //באותיות בזוג ה K
                else if(str[k-1] == str[length-k]) {
                //מגדיר את  את כמות הטעויות שגילו את כמו לכמות הטעיות לזוג הנוכחי
                    dp[n][k][b] = dp[n][k-1][b];
                    // אם יש לנו יותר משתי אפשרויות החלפה
                    if(n>=2) 
                      {
                      //    מעלה את כמות ההחלפות ב25
                      //בB הנוכחי שנמצאים בו 
                        dp[n][k][b] = (dp[n][k][b] + 25 * dp[n-2][k-1][b]) % MAX_N;
                      }
                }
                //אם זוג האותיות ה
                // K
                // לא שווה
                else if(str[k-1] != str[length-k]) {
                // אם ניתן לשנות לפחות אות אחת  ונותר לנו טעות אחת לפחות 
                    if(b>=1 && n>=1) {
                        dp[n][k][b] = 2 * dp[n-1][k-1][b-1];
                    }
                    //אם יש אפשרות להחליף יותר מאות אחת
                    if(n>=2){
                          dp[n][k][b] = (dp[n][k][b] + 24 * dp[n-2][k-1][b-1]) % MAX_N;
                    }
                }
            }
        }
    }
    מחזיר את כמות החילופים האפשרים
    return dp[N][num_group][num_mismatch];
}

int main() {
    int T; // כמות בדיקות 
    cin >> T; //קליטת כמות בדיקות
    string str; // מילה שאותה בודקים 
    int n;
    
    //קליטה של כל אחד מהבדיקות 
    for(int t=0; t<T; t++) {
        cin >> n >> str; // קליטת המספר ה N  ו קליטת המילה 
        cout << NPalindromes(str, n) << endl; // שליחה לפונקציה שבודת ודפסת התוצאה 
    }
    
    return 0;
}
